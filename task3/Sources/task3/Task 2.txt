Task 2

let serialQueue = DispatchQueue(label: "com.foo.bar") 
serialQueue.async { 
	print("Work 1") 
	serialQueue.sync { 
		print("Work 2") 
	} 
}

Для начала немного немного о теории GCD очередей, касающейся данного вопроса, есть два типа - параллельные (способные псеводо-параллельно выполнять задачи) и последовательные (выполняющие задачи только посследовательно, например "мейнтред").

В эти очереди можно добавлять код синхронно и асинхронно, главное различие в том что при синхронном добавлении блокируется текущая очередь и управление передается до завершения выполнения задачи.

В данном примере мы видим последовательную очередь, в которую асинхронно добавляется "работа 1" которая в саму себя пытается добавить код синронно, т.е. заблокировать текущую очередь выполнения, то есть саму себя, создается deadlock.

данную ситуацию можно избежать несколькими способами c разными послдовательностями выполнения работы: 

1)
let serialQueue = DispatchQueue(label: "com.foo.bar") 
serialQueue.async { 
	print("Work 1") 
	serialQueue.async {
        print("work2")
    }
    print("work3")
}

Вывод - 
work1
work3 // т.к. очередь последовательная, сначала выполнится работа 3 а потом добавления работа 2 
work2

2) ситуацию можно избежать использовав параллельню очередб
let concurrentQueue = DispatchQueue(label: "com.foo.bar", attributes: .concurrent)) 
concurrentQueue.async { 
	print("Work 1") 
	concurrentQueue.sync { 
        print("work2")
    }
    print("work3")
}

Вывод - 
work1
work2
work3

// в даном случае очередь параллельная и может приостановить текущий процесс для выолнения другого. (в случае использования async(2й раз) не возможно предсказать порядок выполнения work2 и work3 - он будет зависеть от параметров системы)